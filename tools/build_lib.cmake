# __component_add_sources, __component_check_target, __component_add_include_dirs
#
# Utility macros for component registration. Adds source files and checks target requirements,
# and adds include directories respectively.
macro(__parse_sources sources)
    set(sources "")
    if(__SRCS)
        if(__SRC_DIRS)
            message(WARNING "SRCS and SRC_DIRS are both specified; ignoring SRC_DIRS.")
        endif()
        foreach(src ${__SRCS})
            get_filename_component(src "${src}" ABSOLUTE BASE_DIR ${COMPONENT_DIR})
            list(APPEND sources ${src})
        endforeach()
    else()
        if(__SRC_DIRS)
            foreach(dir ${__SRC_DIRS})
                get_filename_component(abs_dir ${dir} ABSOLUTE BASE_DIR ${COMPONENT_DIR})

                if(NOT IS_DIRECTORY ${abs_dir})
                    message(FATAL_ERROR "SRC_DIRS entry '${dir}' does not exist.")
                endif()

                file(GLOB dir_sources "${abs_dir}/*.c" "${abs_dir}/*.cpp" "${abs_dir}/*.S")
                list(SORT dir_sources)

                if(dir_sources)
                    foreach(src ${dir_sources})
                        get_filename_component(src "${src}" ABSOLUTE BASE_DIR ${COMPONENT_DIR})
                        list(APPEND sources "${src}")
                    endforeach()
                else()
                    message(WARNING "No source files found for SRC_DIRS entry '${dir}'.")
                endif()
            endforeach()
        endif()

        if(__EXCLUDE_SRCS)
            foreach(src ${__EXCLUDE_SRCS})
                get_filename_component(src "${src}" ABSOLUTE)
                list(REMOVE_ITEM sources "${src}")
            endforeach()
        endif()
    endif()

    list(REMOVE_DUPLICATES sources)
endmacro()

macro(__add_include_dirs lib dirs type)
    foreach(dir ${dirs})
        get_filename_component(_dir ${dir} ABSOLUTE BASE_DIR ${CMAKE_CURRENT_LIST_DIR})
        if(NOT IS_DIRECTORY ${_dir})
            message(FATAL_ERROR "Include directory '${_dir}' is not a directory.")
        endif()
        target_include_directories(${lib} ${type} ${_dir})
    endforeach()
endmacro()

macro(__add_dependencys_path dirs depds)
    set(extra_lib_path)
    foreach(depd ${depds})
        list(APPEND extra_lib_path "${dirs}/${depd}")
    endforeach()
    link_directories(${extra_lib_path})
    message(STATUS "extra_lib_path: ${extra_lib_path}")
endmacro()

macro(__add_dependencys lib dirs depds type)
    foreach(depd ${depds})
        target_link_libraries(${lib} ${type} -l${depd})
    endforeach()
endmacro()

macro(share_lib_add module_name libs_path)
    set(_platform_name "windows")
    if(UNIX)
    message(STATUS "current platform: Linux ")
    set(_platform_name "linux")
    elseif(WIN32)
    message(STATUS "current platform: Windows ")
    else()
    message(FATAL_ERROR "current platform: unkonw ")
    endif()    
    set(CMAKE_INCLUDE_CURRENT_DIR ON)
    message(STATUS "libs in: ${libs_path}")
    _share_lib_add(${module_name} ${libs_path} ${ARGV})
endmacro()

macro(project_share_lib libs_path)
    #get module name from folder name
    get_filename_component(PARENT_DIR ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    set(_module_name "${PARENT_DIR}")
    message(STATUS "name: ${_module_name}")
    share_lib_add(${_module_name} ${libs_path} ${ARGV})
endmacro()


function(_get_version version file_path)
    #get module version from version.txt
    if(EXISTS ${file_path})
        file(READ ${file_path} ver)
        string(REGEX MATCH "VERSION_MAJOR ([0-9]*)" _ ${ver})
        set(ver_major ${CMAKE_MATCH_1})
        string(REGEX MATCH "VERSION_MINOR ([0-9]*)" _ ${ver})
        set(ver_minor ${CMAKE_MATCH_1})
        string(REGEX MATCH "VERSION_PATCH ([0-9]*)" _ ${ver})
        set(ver_patch ${CMAKE_MATCH_1})
        message(STATUS "${ver_major}.${ver_minor}.${ver_patch}")
        set(${version} "${ver_major}.${ver_minor}.${ver_patch}" PARENT_SCOPE)
    else()
        message(WARNING " ${file_path} not exist")
        set(version "0.0.0" PARENT_SCOPE)
    endif()
endfunction()

function(_share_lib_add lib_name libs_path)
    set(options)
    set(single_value VERSION)
    set(multi_value SRCS SRC_DIRS EXCLUDE_SRCS
                    INCLUDE_DIRS PRIV_INCLUDE_DIRS
                    REQUIRES PRIV_REQUIRES EXPORT_HEADERS)
    cmake_parse_arguments(_ "${options}" "${single_value}" "${multi_value}" ${ARGN})
    list(APPEND __SRC_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/src)
    list(APPEND __INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/include)
    message(STATUS "SRC_DIRS:" ${__SRC_DIRS})

    __parse_sources(sources)
    message(STATUS "SRCS:" ${sources})
    set(_lib_path ${libs_path}/dll/${_platform_name})
    set(_lib_inc_public "include/${lib_name}.h" "include/export_global.h" ${__EXPORT_HEADERS})
    set(_lib_version_file "version.txt")
    set(_current_path_version_file ${CMAKE_CURRENT_SOURCE_DIR}/${_lib_version_file})
    set(_lib_path_version_file ${_lib_path}/${lib_name}/${_lib_version_file})
    set(_module_version "0.0.0")
    set(_module_installed_version "0.0.0")
    _get_version(_module_version ${_current_path_version_file})
    _get_version(_module_installed_version ${_lib_path_version_file})
    message(STATUS "new version: ${_module_version}")
    message(STATUS "old version: ${_module_installed_version}")
    if(${_module_version} VERSION_GREATER ${_module_installed_version})
        message(STATUS "new version found!")
    else()
        message(WARNING "new version not found!")
        set(_module_version "0.0.0")
    endif()

    if(sources)
        __add_dependencys_path(${_lib_path} "${__REQUIRES}")
        __add_dependencys_path(${_lib_path} "${__PRIV_REQUIRES}")
        add_library(${lib_name} SHARED ${sources})
        __add_include_dirs(${lib_name} "${__INCLUDE_DIRS}" PUBLIC)
        __add_include_dirs(${lib_name} "${__PRIV_INCLUDE_DIRS}" PRIVATE)
        target_compile_definitions(${lib_name} PRIVATE EXPORT_LIBRARY)
        __add_dependencys(${lib_name} ${_lib_path} "${__REQUIRES}" PUBLIC)
        __add_dependencys(${lib_name} ${_lib_path} "${__PRIV_REQUIRES}" PRIVATE)
        __add_include_dirs(${lib_name} "${libs_path}/include" PUBLIC)
        if(${_module_version} VERSION_GREATER "0.0.0")
            install(TARGETS ${lib_name} DESTINATION "${_lib_path}/${lib_name}")
            install(FILES ${_lib_version_file} DESTINATION "${_lib_path}/${lib_name}")    
            install(FILES ${_lib_inc_public} DESTINATION "${libs_path}/include/${lib_name}")
        else()
            install(FILES)
            message(WARNING "no new version found! will not install")
        endif()
    else()
        message(FATAL_ERROR "no source files found!")
    endif()
endfunction()